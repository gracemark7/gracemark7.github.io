(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{226:function(t,e,_){"use strict";_.r(e);var s=_(0),v=Object(s.a)({},(function(){var t=this,e=t.$createElement,_=t._self._c||e;return _("div",{staticClass:"content"},[t._m(0),t._v(" "),t._m(1),t._v(" "),t._m(2),t._v(" "),_("p",[t._v("CSS moudle（模组化）")]),t._v(" "),_("p",[t._v("每个 jsx 或者 tsx 文件就被视为一个独立存在的原件")]),t._v(" "),_("p",[t._v("原件所包含的所有内容也同样都应该是独立存在的")]),t._v(" "),_("p",[t._v("import './index.css' --\x3e import style from './index.css'")]),t._v(" "),t._m(3),t._v(" "),t._m(4),t._v(" "),t._m(5),t._v(" "),_("p",[t._v("区别：")]),t._v(" "),_("p",[t._v("props 是组件对外的接口，而 state 是组件对内的接口")]),t._v(" "),_("p",[t._v("props 用于组件间数据传递，而 state 用于组件内部的数据传递")]),t._v(" "),t._m(6),t._v(" "),t._m(7),t._v(" "),_("p",[t._v("State 的更新是异步的，调用 setState 后，不会立刻改变，是异步操作；不要依赖当前的 State，计算下个 State")]),t._v(" "),t._m(8),t._v(" "),_("p",[t._v("Immutable 不变的 对象一旦创建就不可改变，只能通过销毁、创建来改变数据")]),t._v(" "),_("p",[t._v("通过判断内存地址的是否一致，来确认对象是否有经过修改")]),t._v(" "),_("p",[t._v("只读属性")]),t._v(" "),t._m(9),t._v(" "),_("p",[t._v("ImmutableJS Redux Observable（RxJS)")]),t._v(" "),t._m(10),t._v(" "),_("p",[t._v("e.target 事件发生的元素")]),t._v(" "),_("p",[t._v("e.currentTarget 事件处理绑定单位元素")]),t._v(" "),t._m(11),t._v(" "),_("p",[_("a",{attrs:{href:"https://jsonplaceholder.typicode.com/",target:"_blank",rel:"noopener noreferrer"}},[t._v("获取网络测试数据"),_("OutboundLink")],1)]),t._v(" "),t._m(12),t._v(" "),t._m(13),t._v(" "),_("p",[t._v("生命周期第一阶段：初始化\n  初始化组件 state")]),t._v(" "),_("p",[t._v("constructor")]),t._v(" "),_("p",[t._v("componentDidMount")]),t._v(" "),_("p",[t._v("生命周期第二阶段：更新")]),t._v(" "),_("p",[t._v("在组件接收到一个新的 prop（更新后）时被调用")]),t._v(" "),_("p",[t._v("static getDerivedStateFromProps(props, state)")]),t._v(" "),_("p",[t._v("componentWillReceiveProps(){} 已经废弃")]),t._v(" "),_("p",[t._v("shouldComponentUpdate(nextProps,nextState){}")]),t._v(" "),_("p",[t._v("组件更新后调用")]),t._v(" "),_("p",[t._v("componentDidUpdate(){}")]),t._v(" "),_("p",[t._v("生命周期第三阶段：销毁")]),t._v(" "),_("p",[t._v("componentWillUnmount(){}")]),t._v(" "),t._m(14),t._v(" "),_("p",[t._v("支持逐步升级")]),t._v(" "),_("p",[t._v("事件委托机制改变")]),t._v(" "),_("p",[t._v("向原生浏览器靠拢")]),t._v(" "),_("p",[t._v("删除事件池")]),t._v(" "),_("p",[t._v("useEffect 清理操作改为异步操作")]),t._v(" "),_("p",[t._v("JSX 不可返回 undefined")]),t._v(" "),_("p",[t._v("删除部分私有 API")]),t._v(" "),t._m(15),t._v(" "),t._m(16),t._v(" "),_("p",[t._v("消息处理的一种方法，用来监听指定程序")]),t._v(" "),_("p",[t._v("函数组件中需要处理副作用，可以用钩子把外部代码“钩”进来")]),t._v(" "),_("p",[t._v("常用的钩子：useState，useEffect，useContext，useReducer")]),t._v(" "),_("p",[t._v("hooks 一律使用 use 前缀命名：useXxx")]),t._v(" "),_("p",[t._v("本质：一类特殊的函数，为你的函数式组件注入特殊的功能")]),t._v(" "),_("p",[t._v("why:\n有些类组件冗长而且复杂，难以复用")]),t._v(" "),_("p",[t._v("结局方案：无状态组件与 HOC(高阶组件),但是存在诸多问题")]),t._v(" "),_("p",[t._v("目的：")]),t._v(" "),_("p",[t._v("给函数式组件加上状态")]),t._v(" "),_("p",[t._v("生命周期函数会同时处理多项任务：发起 ajax、跟踪数据状态、绑定事件监听")]),t._v(" "),_("p",[t._v("函数式组件则轻量化很多，使用 Hooks 钩子来钩入组件状态")]),t._v(" "),_("p",[t._v("不再需要类组件")]),t._v(" "),_("p",[t._v("不会再有 this、不会再有 binding、甚至有可能取代 redux")]),t._v(" "),_("p",[t._v("useState：声明组件状态")]),t._v(" "),_("p",[t._v("useEffect：副作用钩子，可以取代\ncomponentDidMount、\ncomponentDidUpdate、\ncomponentWillUnmount")]),t._v(" "),_("p",[t._v("给函数式组件添加副作用（side effect）")]),t._v(" "),_("p",[t._v("纯函数（pure function）")]),t._v(" "),_("p",[t._v("副作用与纯函数相反，指一个函数处理了与返回值无关的事情")]),t._v(" "),t._m(17),t._v(" "),_("p",[t._v("Context 提供了一个无需为每层组件手动添加 props，就能在组件树间进行数据传递的方法。")]),t._v(" "),_("p",[t._v("Context 设计目的是为了共享那些对于一个组件树而言是“全局”的数据。")]),t._v(" "),t._m(18),t._v(" "),_("p",[t._v("进阶--性能优化、原理")])])}),[function(){var t=this.$createElement,e=this._self._c||t;return e("h4",{attrs:{id:"基础篇"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#基础篇"}},[this._v("#")]),this._v(" 基础篇")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h5",{attrs:{id:"三、react-与-typescript"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#三、react-与-typescript"}},[this._v("#")]),this._v(" 三、React 与 TypeScript")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("CSS 模组")]),this._v(" JSS：")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("CSS in JS (JSS)添加样式")]),this._v('意思就是使用 JS 语言写 CSS。React  出现以后，这个原则不再适用了。因为，React 是组件结构，强制要求把 HTML、CSS、JavaScript 写在一起。这有利于组件的隔离。每个组件包含了所有需要用到的代码，不依赖外部，组件之间没有耦合，很方便复用。所以，随着 React 的走红和组件模式深入人心，这种"关注点混合"的新写法逐渐成为主流。')])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("加载媒体与字体文件")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h6",{attrs:{id:"state-与-props"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#state-与-props"}},[this._v("#")]),this._v(" state 与 props")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("State")]),this._v("是私有的，可以认为 state 是组件的“私有属性”，用 setState()修改 State")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("构建函数 constructor 是唯一可以"),e("strong",[this._v("初始化")]),this._v("state 的地方")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("Props")]),this._v("：Properties 缩写，本质上，props 就是传入函数的参数，是从传入组件内部的数据，更准确地说，是从父组件传递向子组件的数据")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("函数式编程理念")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("事件驱动 React Event 事件处理:")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("异步处理获取网络 API 数据")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("setState（）")]),this._v(" 异步更新，同步执行；setState（）本身并非异步，但对 state 的处理机制给人一种异步的假象。state 处理一般发生在生命周期变化的时候。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("生命周期：")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("17 版本变化：")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h4",{attrs:{id:"生态篇"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#生态篇"}},[this._v("#")]),this._v(" 生态篇")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("1、"),e("strong",[this._v("Hooks")]),this._v(" 钩子\nwhat：\n非类组件中使用 state")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("Context 与 useContext")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("strong",[this._v("组件化 Context Provider")])])}],!1,null,null,null);e.default=v.exports}}]);